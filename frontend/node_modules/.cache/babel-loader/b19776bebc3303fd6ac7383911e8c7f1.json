{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _helpers = require('./helpers');\n\nvar _styles = require('./styles');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar MIN_ZOOM = 1;\nvar MAX_ZOOM = 3;\n\nvar Cropper = function (_React$Component) {\n  _inherits(Cropper, _React$Component);\n\n  function Cropper() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Cropper);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Cropper.__proto__ || Object.getPrototypeOf(Cropper)).call.apply(_ref, [this].concat(args))), _this), _this.image = null, _this.container = null, _this.containerRect = {}, _this.imageSize = {\n      width: 0,\n      height: 0,\n      naturalWidth: 0,\n      naturalHeight: 0\n    }, _this.dragStartPosition = {\n      x: 0,\n      y: 0\n    }, _this.dragStartCrop = {\n      x: 0,\n      y: 0\n    }, _this.lastPinchDistance = 0, _this.rafDragTimeout = null, _this.rafZoomTimeout = null, _this.state = {\n      cropSize: null\n    }, _this.preventZoomSafari = function (e) {\n      return e.preventDefault();\n    }, _this.cleanEvents = function () {\n      document.removeEventListener('mousemove', _this.onMouseMove);\n      document.removeEventListener('mouseup', _this.onDragStopped);\n      document.removeEventListener('touchmove', _this.onTouchMove);\n      document.removeEventListener('touchend', _this.onDragStopped);\n    }, _this.onImgLoad = function () {\n      _this.computeSizes();\n\n      _this.emitCropData();\n    }, _this.computeSizes = function () {\n      if (_this.image) {\n        _this.imageSize = {\n          width: _this.image.width,\n          height: _this.image.height,\n          naturalWidth: _this.image.naturalWidth,\n          naturalHeight: _this.image.naturalHeight\n        };\n        var cropSize = (0, _helpers.getCropSize)(_this.image.width, _this.image.height, _this.props.aspect);\n\n        _this.setState({\n          cropSize: cropSize\n        }, _this.recomputeCropPosition);\n      }\n\n      if (_this.container) {\n        _this.containerRect = _this.container.getBoundingClientRect();\n      }\n    }, _this.onMouseDown = function (e) {\n      e.preventDefault();\n      document.addEventListener('mousemove', _this.onMouseMove);\n      document.addEventListener('mouseup', _this.onDragStopped);\n\n      _this.onDragStart(Cropper.getMousePoint(e));\n    }, _this.onMouseMove = function (e) {\n      return _this.onDrag(Cropper.getMousePoint(e));\n    }, _this.onTouchStart = function (e) {\n      e.preventDefault();\n      document.addEventListener('touchmove', _this.onTouchMove, {\n        passive: false\n      }); // iOS 11 now defaults to passive: true\n\n      document.addEventListener('touchend', _this.onDragStopped);\n\n      if (e.touches.length === 2) {\n        _this.onPinchStart(e);\n      } else if (e.touches.length === 1) {\n        _this.onDragStart(Cropper.getTouchPoint(e.touches[0]));\n      }\n    }, _this.onTouchMove = function (e) {\n      if (e.touches.length === 2) {\n        _this.onPinchMove(e);\n      } else if (e.touches.length === 1) {\n        _this.onDrag(Cropper.getTouchPoint(e.touches[0]));\n      }\n    }, _this.onDragStart = function (_ref2) {\n      var x = _ref2.x,\n          y = _ref2.y;\n      _this.dragStartPosition = {\n        x: x,\n        y: y\n      };\n      _this.dragStartCrop = {\n        x: _this.props.crop.x,\n        y: _this.props.crop.y\n      };\n    }, _this.onDrag = function (_ref3) {\n      var x = _ref3.x,\n          y = _ref3.y;\n      if (_this.rafDragTimeout) window.cancelAnimationFrame(_this.rafDragTimeout);\n      _this.rafDragTimeout = window.requestAnimationFrame(function () {\n        if (x === undefined || y === undefined) return;\n        var offsetX = x - _this.dragStartPosition.x;\n        var offsetY = y - _this.dragStartPosition.y;\n        var requestedPosition = {\n          x: _this.dragStartCrop.x + offsetX,\n          y: _this.dragStartCrop.y + offsetY\n        };\n        var newPosition = (0, _helpers.restrictPosition)(requestedPosition, _this.imageSize, _this.state.cropSize, _this.props.zoom);\n\n        _this.props.onCropChange(newPosition);\n      });\n    }, _this.onDragStopped = function () {\n      _this.cleanEvents();\n\n      _this.emitCropData();\n    }, _this.onWheel = function (e) {\n      e.preventDefault();\n      var point = Cropper.getMousePoint(e);\n      var newZoom = _this.props.zoom - e.deltaY / 200;\n\n      _this.setNewZoom(newZoom, point);\n    }, _this.getPointOnContainer = function (_ref4, zoom) {\n      var x = _ref4.x,\n          y = _ref4.y;\n\n      if (!_this.containerRect) {\n        throw new Error('The Cropper is not mounted');\n      }\n\n      return {\n        x: _this.containerRect.width / 2 - (x - _this.containerRect.left),\n        y: _this.containerRect.height / 2 - (y - _this.containerRect.top)\n      };\n    }, _this.getPointOnImage = function (_ref5) {\n      var x = _ref5.x,\n          y = _ref5.y;\n      var _this$props = _this.props,\n          crop = _this$props.crop,\n          zoom = _this$props.zoom;\n      return {\n        x: (x + crop.x) / zoom,\n        y: (y + crop.y) / zoom\n      };\n    }, _this.setNewZoom = function (zoom, point) {\n      var zoomPoint = _this.getPointOnContainer(point);\n\n      var zoomTarget = _this.getPointOnImage(zoomPoint);\n\n      var newZoom = Math.min(_this.props.maxZoom, Math.max(zoom, _this.props.minZoom));\n      var requestedPosition = {\n        x: zoomTarget.x * newZoom - zoomPoint.x,\n        y: zoomTarget.y * newZoom - zoomPoint.y\n      };\n      var newPosition = (0, _helpers.restrictPosition)(requestedPosition, _this.imageSize, _this.state.cropSize, newZoom);\n\n      _this.props.onCropChange(newPosition);\n\n      _this.props.onZoomChange && _this.props.onZoomChange(newZoom);\n    }, _this.emitCropData = function () {\n      if (!_this.state.cropSize) return; // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ricardo-ch/react-easy-crop/issues/6)\n\n      var restrictedPosition = (0, _helpers.restrictPosition)(_this.props.crop, _this.imageSize, _this.state.cropSize, _this.props.zoom);\n\n      var _computeCroppedArea = (0, _helpers.computeCroppedArea)(restrictedPosition, _this.imageSize, _this.state.cropSize, _this.props.zoom),\n          croppedAreaPercentages = _computeCroppedArea.croppedAreaPercentages,\n          croppedAreaPixels = _computeCroppedArea.croppedAreaPixels;\n\n      _this.props.onCropComplete && _this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels);\n    }, _this.recomputeCropPosition = function () {\n      var newPosition = (0, _helpers.restrictPosition)(_this.props.crop, _this.imageSize, _this.state.cropSize, _this.props.zoom);\n\n      _this.props.onCropChange(newPosition);\n\n      _this.emitCropData();\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Cropper, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      window.addEventListener('resize', this.computeSizes);\n      this.container.addEventListener('gesturestart', this.preventZoomSafari);\n      this.container.addEventListener('gesturechange', this.preventZoomSafari);\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      window.removeEventListener('resize', this.computeSizes);\n      this.container.removeEventListener('gesturestart', this.preventZoomSafari);\n      this.container.removeEventListener('gesturechange', this.preventZoomSafari);\n      this.cleanEvents();\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.aspect !== this.props.aspect) {\n        this.computeSizes();\n      } else if (prevProps.zoom !== this.props.zoom) {\n        this.recomputeCropPosition();\n      }\n    } // this is to prevent Safari on iOS >= 10 to zoom the page\n\n  }, {\n    key: 'onPinchStart',\n    value: function onPinchStart(e) {\n      var pointA = Cropper.getTouchPoint(e.touches[0]);\n      var pointB = Cropper.getTouchPoint(e.touches[1]);\n      this.lastPinchDistance = (0, _helpers.getDistanceBetweenPoints)(pointA, pointB);\n      this.onDragStart((0, _helpers.getCenter)(pointA, pointB));\n    }\n  }, {\n    key: 'onPinchMove',\n    value: function onPinchMove(e) {\n      var _this2 = this;\n\n      var pointA = Cropper.getTouchPoint(e.touches[0]);\n      var pointB = Cropper.getTouchPoint(e.touches[1]);\n      var center = (0, _helpers.getCenter)(pointA, pointB);\n      this.onDrag(center);\n      if (this.rafZoomTimeout) window.cancelAnimationFrame(this.rafZoomTimeout);\n      this.rafZoomTimeout = window.requestAnimationFrame(function () {\n        var distance = (0, _helpers.getDistanceBetweenPoints)(pointA, pointB);\n        var newZoom = _this2.props.zoom * (distance / _this2.lastPinchDistance);\n\n        _this2.setNewZoom(newZoom, center);\n\n        _this2.lastPinchDistance = distance;\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this3 = this;\n\n      var _props = this.props,\n          _props$crop = _props.crop,\n          x = _props$crop.x,\n          y = _props$crop.y,\n          zoom = _props.zoom,\n          cropShape = _props.cropShape,\n          showGrid = _props.showGrid,\n          _props$style = _props.style,\n          containerStyle = _props$style.containerStyle,\n          cropAreaStyle = _props$style.cropAreaStyle,\n          imageStyle = _props$style.imageStyle,\n          _props$classes = _props.classes,\n          containerClassName = _props$classes.containerClassName,\n          cropAreaClassName = _props$classes.cropAreaClassName,\n          imageClassName = _props$classes.imageClassName;\n      return _react2.default.createElement(_styles.Container, {\n        onMouseDown: this.onMouseDown,\n        onTouchStart: this.onTouchStart,\n        onWheel: this.onWheel,\n        innerRef: function innerRef(el) {\n          return _this3.container = el;\n        },\n        'data-testid': 'container',\n        containerStyle: containerStyle,\n        className: containerClassName\n      }, _react2.default.createElement(_styles.Img, {\n        src: this.props.image,\n        innerRef: function innerRef(el) {\n          return _this3.image = el;\n        },\n        onLoad: this.onImgLoad,\n        onError: this.props.onImgError,\n        alt: '',\n        style: {\n          transform: 'translate(' + x + 'px, ' + y + 'px) scale(' + zoom + ')'\n        },\n        imageStyle: imageStyle,\n        className: imageClassName\n      }), this.state.cropSize && _react2.default.createElement(_styles.CropArea, {\n        cropShape: cropShape,\n        showGrid: showGrid,\n        style: {\n          width: this.state.cropSize.width,\n          height: this.state.cropSize.height\n        },\n        'data-testid': 'cropper',\n        cropAreaStyle: cropAreaStyle,\n        className: cropAreaClassName\n      }));\n    }\n  }]);\n\n  return Cropper;\n}(_react2.default.Component);\n\nCropper.getMousePoint = function (e) {\n  return {\n    x: Number(e.clientX),\n    y: Number(e.clientY)\n  };\n};\n\nCropper.getTouchPoint = function (touch) {\n  return {\n    x: Number(touch.clientX),\n    y: Number(touch.clientY)\n  };\n};\n\nCropper.defaultProps = {\n  zoom: 1,\n  aspect: 4 / 3,\n  maxZoom: MAX_ZOOM,\n  minZoom: MIN_ZOOM,\n  cropShape: 'rect',\n  showGrid: true,\n  style: {},\n  classes: {}\n};\nexports.default = Cropper;","map":null,"metadata":{},"sourceType":"script"}